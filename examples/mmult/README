Hey Andy, heres the gist:


Start on a linux box
----------------------------------
1. Run the python code to test:

python3.6 test.py

It should print out all this stuff:

@time: 25991.91665649414 us
a = [[   1    2    3 ...   30   31   32]
 [  33   34   35 ...   62   63   64]
 [  65   66   67 ...   94   95   96]
 ...
 [ 929  930  931 ...  958  959  960]
 [ 961  962  963 ...  990  991  992]
 [ 993  994  995 ... 1022 1023 1024]]

b = [[   1    2    3 ...   30   31   32]
 [  33   34   35 ...   62   63   64]
 [  65   66   67 ...   94   95   96]
 ...
 [ 929  930  931 ...  958  959  960]
 [ 961  962  963 ...  990  991  992]
 [ 993  994  995 ... 1022 1023 1024]]

c = [[  349712   350240   350768 ...   365024   365552   366080]
 [  858640   860192   861744 ...   903648   905200   906752]
 [ 1367568  1370144  1372720 ...  1442272  1444848  1447424]
 ...
 [15108624 15138848 15169072 ... 15985120 16015344 16045568]
 [15617552 15648800 15680048 ... 16523744 16554992 16586240]
 [16126480 16158752 16191024 ... 17062368 17094640 17126912]]

2. Generate C code for the mmult function:

make

3. Test the generated C code by compiling an executable with main.cpp:

make compile

4. Test the C code with the test main:

./test

It should print out all this stuff:

starting...
calling mmult directly
Elapsed time 75 us
Results match expected
calling mmult indirectly
Elapsed time 75 us
Results match expected
finished

5. Source the 2018.3 tools settings script
6. Do the build by:

source run_sdsoc.tcl

7. When its done, build the c++ test by:

make sdscc

This compiles a test.elf (equivalient to test we ran earlier)

8. Now build the same test by linking against the libcaller.so:

make link

This compiles link.elf (equivalent of test.elf, but links against libcaller.so instead of statically linking the objs)

8. Copy: test.elf, libcaller.so.bit, link.elf over to the board. 

Now move to the board ssh
---------------------------------------
9. Program the bitstream by running this in python3.6:

import pynq
bit = pynq.Bitstream('test.elf.bit')
bit.download()

10. Now run the test:

./test.elf

You should see this stuff print out:

starting...
calling mmult directly
Elapsed time 75 us
Results match expected
calling mmult indirectly
Elapsed time 36 us
Results match expected
finished

So at least we validated that what works on the linux box also works on the pynq board and that the SDSoC generated accelerator works.

11. Now run the link test:

LD_LIBRARY_PATH=$(pwd) ./link.elf 

I see this print out:

starting...
calling mmult directly
Elapsed time 2513 us
Results match expected
calling mmult indirectly
Elapsed time 77 us
Results match expected
finished
